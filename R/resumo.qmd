---
title: "Resumo"
lang: "pt-br"
indenting: first
format: 
  html:
    css: style.css
    indent: true
  
editor: visual

execute:
  echo: false
  warning: false
---

# Estatísticas Descritivas

## Estatísticas das seções em 2018 - 1º turno

```{r}

# leitura da base de dados
dados <- readr::read_csv2(
  file = here::here("data", "base_2018_01.csv"),
  locale = readr::locale(encoding = "latin1")
) |>
  janitor::clean_names() |>
  dplyr::filter(tipo == "bio", subs_urna == 0) |>
  dplyr::mutate(atraso =
                  ifelse(tempo_atraso >= lubridate::hms("01:00:00"), 1, 0)
                )



```

A @fig-histograma apresenta a distribuição dos eleitores dentro das seções que foram 100% biométricas em 2018, enquanto a @tbl-resumo_estat exibe estatísticas referentes a essas seções e a dispersão pode ser visualizada na @fig-bp_secoes.

```{r}
#| fig-cap: "Distribuição dos aptos por seção com biometria em 2018"
#| fig-align: center
#| label: fig-histograma

dados |>
  ggplot2::ggplot(ggplot2::aes(x = qt_aptos)) +
  ggplot2::geom_histogram( fill = "steelblue", color = "white") +
  ggplot2::labs(x = "Eleitores aptos", y = "Frequência") +
  ggplot2::theme_classic()

```

```{r}
#| label: tbl-resumo_estat
#| tbl-cap: "Estatísticas descritivas das seções com biometria na eleição de 2018"

#
resumo_estat <- dados |>
  dplyr::summarise(
    n_secoes = dplyr::n(),
    media_secao =  mean(qt_aptos, na.rm = TRUE),
    mediana_secao = median(qt_aptos, na.rm = TRUE),
    desvpad_secao = sd(qt_aptos, na.rm = TRUE),
    max_secao = max(qt_aptos, na.rm = TRUE),
    min_secao = min(qt_aptos, na.rm = TRUE),
  )

resumo_estat |> 
  gt::gt() |>
  gt::cols_align(align = "center") |>
  
  gt::cols_label(
    n_secoes = "Nº seções",
    media_secao = "Média/seção",
    mediana_secao = "Mediana/seção",
    desvpad_secao = "Desvio padrão",
    min_secao = "Eleitorado menor seção",
    max_secao = "Eleitorado maior seção",
  ) |> 
  gt::fmt_number(
    columns = 2:3,
    decimals = 2,
    dec_mark = ","
  ) |>
  gt::fmt_number(
    columns = 1,
    decimals = 0,
    dec_mark = ",",
    sep_mark = "."
  ) |> 
  gt::tab_style(
    style = gt::cell_text(weight = "bold"),
    locations = gt::cells_column_labels()
  )


```

```{r}
#| label: fig-bp_secoes
#| fig-cap: "Box-plot do número de eleitores aptos nas seções com biometria em 2018"
#| fig-align: center

dados |>
  ggplot2::ggplot(ggplot2::aes(y = qt_aptos, x = 0)) +
  ggplot2::geom_boxplot( fill = "steelblue", width = 0.5) +
  ggplot2::theme_classic() +
  ggplot2::labs(y = "Aptos por seção") + 
  ggplot2::theme(
    axis.title = ggplot2::element_blank(),
    axis.text.x = ggplot2::element_blank(),
    axis.ticks.x = ggplot2::element_blank()
    ) + 
  ggplot2::xlim(-1,1)
```

Na @fig-histograma_tempos podem ser vistos a distribuição dos tempos de atraso, medidos em segundos daquelas seções que utilizaram biometria em 2018.

```{r}
#| label: fig-histograma_tempos
#| fig-cap: "Distribuição do atraso do encerramento da eleição (em min) nas seções biomeétricas em 2018"
#| fig-align: center


dados |>
  dplyr::mutate(tempo_atraso = as.numeric(lubridate::hms(tempo_atraso))/60) |> 
  ggplot2::ggplot(ggplot2::aes(x = tempo_atraso)) +
  ggplot2::geom_histogram( fill = "steelblue", color = "white", bins = 15) +
  ggplot2::labs(x = "Atraso encerramento votação (min)", y = "Frequência") +
  ggplot2::scale_x_continuous(breaks = seq(10, 90, by=5)) +
  ggplot2::theme_classic()
```

## Estatística dos tempos de votação

Disponibilizados os logs das urnas eletrônicas, especificamente das seções em que o voto foi totalmente habilitado biomtericamente em 2018, é possível calcular o tempo total médio de atendimento do eleitor (TMAE) que é o tempo, medido em segundos, desde a habilitação até o encerramento da votação do eleitor. Esse tempo reflete a duração média do processo de votação do eleitor em cada seção para completar os 6 votos necessários nesse pleito. As principais estatísticas decsritivas podem ser vistas na @tbl-resumo_estat_tempo.

```{r}
#| label: tbl-resumo_estat_tempo
#| tbl-cap: "Estatísticas descritivas do tempo total médio de atendimento do eleitor (TMAE em segundos) das seções com biometria na eleição de 2018"

#
resumo_estat_tempos <- dados |>
  dplyr::summarise(
    n_tempo = dplyr::n(),
    media_tempo = mean(atendimento_total_tmae_seg, na.rm = TRUE),
    mediana_tempo = median(atendimento_total_tmae_seg, na.rm = TRUE),
    desvpad_tempo = sd(atendimento_total_tmae_seg, na.rm = TRUE),
    max_tempo = max(atendimento_total_tmae_seg,na.rm = TRUE),
    min_tempo = min(atendimento_total_tmae_seg,na.rm = TRUE),
  )

resumo_estat_tempos |> 
  gt::gt() |>
  gt::cols_align(align = "center") |>
  gt::cols_label(
    n_tempo = "Nº seções",
    media_tempo = "Tempo médio/seção",
    mediana_tempo = "Tempo mediano/seção",
    desvpad_tempo = "Desvio padrão",
    min_tempo = "Menor tempo médio",
    max_tempo = "Maior tempo médio",
  ) |> 
  gt::fmt_number(
    columns = 2:6,
    decimals = 1,
    dec_mark = ","
  ) |>
  gt::fmt_number(
    columns = 1,
    decimals = 0,
    dec_mark = ",",
    sep_mark = "."
  ) |> 
  gt::tab_style(
    style = gt::cell_text(weight = "bold"),
    locations = gt::cells_column_labels()
  )
```

A @fig-bp_tempos representa o box-plot dos tempos totais de votação (TMAE), medidos em segundos. Nota-se a existência de tempos de votação muitos valores discrepantes com relação à massa de dados na cauda superior e poucos na cauda inferior.

```{r}
#| label: fig-bp_tempos
#| fig-cap: "Box-plot do tempo médio total de votação (TMAE) nas seções com biometria em 2018"
#| fig-align: center


dados |>
  ggplot2::ggplot(ggplot2::aes(y = atendimento_total_tmae_seg, x = 0)) +
  ggplot2::geom_boxplot( fill = "steelblue", width = 0.5) +
  ggplot2::theme_classic() +
  ggplot2::labs(y = "Tempo médio total de votação (TMAE)\n(s)") + 
  ggplot2::theme(
    axis.title = ggplot2::element_blank(),
    axis.text.x = ggplot2::element_blank(),
    axis.ticks.x = ggplot2::element_blank()
    ) + 
  ggplot2::xlim(-1,1)
```

# Modelo de calibração

```{r}
#| label: fig-graf_disp
#| fig-cap: "Gráfico de dispersão entre os tempos total de votação médio e eleitores aptos na seção"
#| fig-align: center

dados |>
  dplyr::group_by(tipo) |>
  ggplot2::ggplot(ggplot2::aes(x = qt_aptos,
                               y = atendimento_total_tmae_seg)) +
  ggplot2::geom_point(color = "steelblue" , alpha = 0.3) +
  ggplot2::geom_smooth(method = "lm", se = TRUE, color = "black") +
  ggplot2::labs(x = "Eleitores aptos por seção", y = "Tempo total médio de votação\n(s)" )+
  ggplot2::theme_classic()
```

$$
y_{i} = \alpha + \beta x_i + \epsilon_{i}, \quad i= 1, \dots, n 
$$ {#eq-etapa_1}

$$
\hat{x} = \frac{y_{desejado} - \hat{\alpha}}{\hat{\beta}}
$$ {#eq-etapa_2}

Onde a @eq-etapa_1, $y_{i}$ é a variável resposta, no presente caso, o tempo total médio de votação, $x_{i}$ a variável independente, a quantidade de aptos, ambas na i-ésima seção, e $\alpha$ e $\beta$, parâmetros do modelo de regressão a serem estimados.

O segundo estágio (@eq-etapa_2), tem por objetivo estimar variável independente da @eq-etapa_1, $\hat{x}$, dado um valor de $y_{desejado}$ e os parâmetros e $\alpha$ e $\beta$ estimados na regressão da primeira etapa. Transpondo para a siuação atual, estima-se na primeira etapa uma regressão linear simples do tempo médio de votação em função da quantidade de aptos da seção e na segunda etapa, o valor da quantidade de aptos estimado dado o tempo médio de votação específico e os parâmetros do modelo estimado, que é a resposta do problema

### Resultado utilizando o valor mediano do TMAE (81 s)

Considerando o valor mediano do tempo total médio de votação dos eleitores em seções com votação biométrica no pleito de 2018, `r scales::number(resumo_estat_tempos$mediana_tempo, decimal.mark = ",", accuracy = 0.1)` segundos.

```{r}
# modelo de calibracao  ---------------------------------------------------

# ajuste o modelo de regressao linear
modelo_lm <- lm(atendimento_total_tmae_seg ~ qt_aptos, data = dados)

# estimativas dos parametros do modelo
resultados <- summary(modelo_lm)

# extrai o valor do alpha
alpha <- coef(modelo_lm)[[1]]

# extrai o valor do beta
beta <- coef(modelo_lm)[[2]]

# calcula o parametro de calibracao (81s)
x0 <- (resumo_estat_tempos$mediana_tempo - alpha) / beta

# calcula a variancia estimada do parametro de calibracao
xbar <- mean(dados$qt_aptos)
n <- nrow(dados)
nsxx <- (n - 1) * var(dados$qt_aptos)
sigma2 <- resultados$sigma ^ 2
varx0 <- (sigma2 / beta ^ 2) * (1 + 1 / n + ((xbar - x0) ^ 2) / nsxx)


```